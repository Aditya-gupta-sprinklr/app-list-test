(*)tags -> p , h1 , div ...so on.
(*)if start then end also.
    <p> -> </p> //para
    <div> </div> //container
(*)attributes give additional info about the tags.
    ex style , class
(*) class is an attribute which can be designed

<style>
.example{       ///pay attention to the '.'
    color:blue;
}
</style>

div<class="example">this will be blue</div>
(*)id is also an attribute and its unique for an element.

<style>
#ex2{       ///pay attention to the '#'
    color:red;
    background-color: lightblue;
}
</style>
<p id="ex2">this is border</p>

(*)radio button->MCQ

<input type="radio" name="fav_lan" value="eng">
///name should be same then only it will become single 
//correct else multi correct lol

//value contains thing ehioch goes to server when this option 
//is selected on pressing submit.
<label>English</label>
<input type="radio" name="fav_lan" value="Hindi">
<label>English</label>


option tag->dropdowns.

(*)link tab of html used to link an external css sheet to it.
places in head of html code.
<head>
  <link rel="stylesheet" href="styles.css">
</head>

//DOM
(*)document.querySelector(".CLass_Name");//firstelementwith//class as Class_Name
(*)document.querySelector("#id_name");//elementwith id as id_name
(*)element.addEventListener("click", myFunction);

function myFunction() {
  document.getElementById("demo").innerHTML = "Hello World";
}

here in the addEventListener 2nd parameter is myFunction and not myFunction() bcz myfunction is a fucntion but myfunction() is something that is returned when myFucntion is calles with defualt parameters. we want the first scenario hence we passed myFunction .
(*)
let name="AG";
console.log(`hello ${name} !`);
(*)

let obj1={
    name:AG,
    age:20,
    city:Delhi,
};

obj1.name===obj1["name"] ///true


(*) let obj1={
    name:AG,
    age:20,
    city:Delhi,
};

obj1 contains address to the complete object.
(*) 
let obj1={
    name:"AG",
};
let obj2={
    full_name:"AdityaGupta",
};
object.assign(user1 ,obj1 ,obj2);
//both works 
console.log(user1.name);
console.log(user1.full_name);
//drawback
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, same object

// user and clone share sizes

//let clone = structuredClone(user);// used for nested object structures

//this keyword refers to the object itself ..u can do return this for a method or this.some_var_of_obj to access its properties.

(*)//CONSTRUCTOR

function User(college){
    //let this={};//implicitly done by compiler.

    this.name="RJ";
    this.age=34;
    this.school=college;

    //return this;///implicitly done by compiler.

}

let obj1=new User("iit");

(*)"?."

let myname=obj?.name;//if obj exist return obj.name else undefined shortens code ..nothing else.
(*)Symbols are created with Symbol() call with an optional description (name).

Symbols are always different values, even if they have the same name. 
let id=Symbol("id");
let id2=Symbol("id");//different;
let obj1={
    [id2]:45,///sqr brackets are necessary ...simple id2 is //differnt thing here.
    id2:55,
};
console.log(obj1[id2]);
If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.

The Symbol.keyFor internally uses the global symbol registry to look up the key for the symbol.

(*)for (key in obj_name)
{
    console.log(key);
}

for(x of arr_name)//or string
{

}
(*)Map – is a collection of keyed values.
use map.set(obj_name,56) and map.get(obj_name);
The differences from a regular Object:

keys can be anything, objects can be keys.

set nique values...set .add , set .delete.

ForEach() - 3:25 - 5:30
Filter() - 5:30 - 15:30   (8:55 One liner filter code) (filter will returns an filtered array - meaning you do not need a separate variable for an array)
Map() - 15:45 - 21:05  creates a new arry acc. to funtion given.
Sort() - 21:10 - 25:50 (Takes two params)
Reduce() - 25:50 - 30:55 (Reduces the array to a single value - from LEFT to RIGHT)
(*)let user = {
  name: "John",
  age: 30
};
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]  

(*)this works , known as destructuring

let user={
    name:"john",
    years:30,

};
//Syntax
let {prop : varName = default, ...rest} = object
//example
let {name:Name , years:age  , isAdmin:isAdmin=false}=user;

basically i am copying rhs object into lhs object.
nothing more about destructuring

same for array.

//Syntax
eX: [item1 = default, item2, ...rest] = array
(*)
let date=new Date(2011,0,1)//1 Jan 2011, 00:00:00//time not given hence zero
let date2=new Date(year, month, date, hours, minutes, seconds, ms)
(*)
JSON supports plain objects, arrays, strings, numbers, booleans, and null.
JavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
Both methods support transformer functions for smart reading/writing.
If an object has toJSON, then it is called by JSON.stringify.

(*)**bind function**

let user={
    name:"AG",
    sayhi(){
        console.log(`hello Mr. ${this.name}`);
    },
}

setTimeout(user.sayhi,1000);//this gives undefined o/p
//reason is it stores user.sayhi in a separate varoable say "x" which do not has refernce  to  object user hence unable to find value of this.name;
//to solve this issue we use. bind function which bind a reference to it.
example:
gd_sayhi=user.sayhi.bind(user);
//now do
setTimeout(gd_sayhi,1000);///works fine 

class Button {
  constructor(value) {
    this.value = value;
  }
   ///this way of defining also helps in losing this
  click = () => 
  {
    alert(this.value);
  }
}
//The class field click = () => {...} is created on a per-object basis, there’s a separate function for each Button object, with this inside it referencing that object. We can pass button.click around anywhere, and the value of this will always be correct.

(*)static --> these functions of class can be used directly by class
example:

class_name.fn_name();

super()///to call constructor of parent class.

(*)

let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};
let obj={

  ismadebygod:true,
  ismammal:true,
  name:homosapiens,
  localname:"AG",

  ishappy(){
    console.log(`if made by god its ${this.ismadebygod}`);
  }
};

obj.__proto__=animal;

In JavaScript, objects have a special hidden property [[Prototype]] (as named in the specification), that is either null or references another object. That object is called “a prototype”:


If we want to read a property of obj or call a method, and it doesn’t exist, then JavaScript tries to find it in the prototype.

obj.walk();
///another way to do the same thing
let animal = {
  jumps: null
};
let rabbit = {
  __proto__: animal,
  jumps: true
};

(*)
parentNode//is unique
childNodes[nodenumber]//indexing like array
firstChild
lastChild
nextSibling
previousSibling


used to navigate in DOM.

(*)content surrounded by padding surrounded by border 
surrounded by margin..
everytinh is boces.
      M
      B
      P
M B P C P B M
      P
      B
      M

When you set the width and height properties of an element with CSS,
 you just set the width and height of the content area. 
 To calculate the full size of an element, you must also add
  padding, borders and margins.

  div {
  width: 320px;
  padding: 10px;
  border: 5px solid gray;
  margin: 0; 
}

(*)in callbacks u pass the complete function to other function do 
whatever u want to do and then at last call the transfeted function/

(*)setTimeout 

//ex: 3 sec baad yeh function run krunga abhi ke liye aage ka 
code run kro isliye aage ka code ka result pehle aa jate hai.

u know.

setInterval can be used to make a real time clock bcz setInterval 
makes the function run after every interval(also given as a 
parameter) passes.

(*)Promisees

let myPromise = new Promise(function(myResolve, myReject) {
// "Producing Code" (May take some time)

  myResolve(); // when successful
  myReject();  // when error
});

// "Consuming Code" (Must wait for a fulfilled Promise)
myPromise.then(
  function(value) { /* code if successful */ },///myResolve
  function(error) { /* code if some error */ }/////myReject
);

promises r like asynchronous codes ..which kind of waits for its 
execution to finish or clear the queue n then move fwd.

"hello"===Promise.resolve("hello")

//write by async , await ...easier to write

async function myDisplay() {
  let myPromise = new Promise(function(resolve) {
    setTimeout(function() {resolve("I love You !!");}, 3000);
  });
  document.getElementById("demo").innerHTML = await myPromise;
  //(2) myPromise called ...though it takes 3 sec ,,,waits for it..
  then its copied it in innerHTML. 
}

myDisplay();///function called(1)

///hence async and await.
///await can be used in async fucntion only which is quiote
...obvii0us.


(*)async and defer.
Both async and defer have one common thing: downloading of such 
scripts doesn’t block page rendering. So the user can read page 
content and get acquainted with the page immediately.

But there are also essential differences between them:

Order	DOMContentLoaded
async	Load-first order. Their document order doesn’t matter – which loads first runs first	;;;;Irrelevant. May load and execute while the document has not yet been fully downloaded. That happens if scripts are small or cached, and the document is long enough.

defer	Document order (as they go in the document).	Execute after the document is loaded and parsed (they wait if needed), right before DOMContentLoaded.




In practice, defer is used for scripts that need the whole DOM a
nd/or their relative execution order is important.

And async is used for independent scripts, like counters or ads. 
And their relative execution order does not matter.


(*)await fetch(url) then await x.JSON();
  // x.JSON chalane ke baad x nhi hai aone pass vo update hogya.
  to get the response body, we need to use an additional method call.

Response provides multiple promise-based methods to access the body in various formats:

response.text() – read the response and return as text,
response.json() – parse the response as JSON,
response.formData() – return the response as FormData object 
(explained in the next chapter),
response.blob() – return the response as Blob (binary data with 
type),
response.arrayBuffer() – return the response as ArrayBuffer 
(low-level representation of binary data),
additionally, response.body is a ReadableStream object, it allows 
you to read the body chunk-by-chunk, we’ll see an example later.
  //we can check download prpogress
  //we can abort using abortController.